<!DOCTYPE html>
<html>
	<head>
		<title>Three.js Binary Triangle Tree Demo</title>
		<link rel="stylesheet" href="css/styles.css">
	</head>
	<body>
		
		
		
		
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
		<script src="js/three.js"></script>
		<script src="js/threestrap.js"></script>
		<script src="js/three.btt.js"></script>
		<script type="text/javascript">
		
			var three;
			var resolution = 5;
			var maxVariance = 0.3;

			// CCW Vertex winding order in THREE.js
			var NORTH = 0;
			var WEST = 1;
			var SOUTH = 2;
			var EAST = 3;


		
			function createBuffer(width, height) {
				var buffer = document.createElement('canvas');
				buffer.width = width;
				buffer.height = height;
				return buffer.getContext('2d');
			}
			
			function drawImage(imageObj, ctx) {
				ctx.drawImage(imageObj, 0, 0);
			}
			
			function getNormalizedHeight ( ctx, x, y ) {
				var pixel = getPixel(ctx, x, y);
				return pixel[0] / 255.0;
			}
			
			function getPixel(ctx, x, y ) {
				x = Math.round(x);
				y = Math.round(y);
				return ctx.getImageData(x, y, 1, 1).data;
			}
			
			
			function createGeometry () {
				var geom = new THREE.Geometry();
				var nVerts = resolution;
				var step = 257.0 / nVerts;
				var start = -(257/2.5);
				for ( var x=0; x<nVerts; x++ ) {
					for (var z=0; z<nVerts; z++ ) {
						geom.vertices.push(
							new THREE.Vector3(start+(x*step), 0.0, start+(z*step))

						);
					}
				}
				return geom;
			}
			
			
			function Triangle (v1, v2, v3) {
				this.v1 = v1;
				this.v2 = v2;
				this.v3 = v3;
			}
			
			Triangle.prototype = {
				constuctor : Triangle,
				v1 : null,
				v2 : null,
				v3 : null,
				bn : null,
				ln : null,
				rn : null,
				lc : null,
				rc : null,

				setBottomNeighbour : function (tri) {
					this.bn = tri;
				},

				setLeftNeighbour : function (tri) {
					this.ln = tri;
				},

				setRightNeighbour : function (tri) {
					this.rn = tri;
				},

				getCardinalDirection : function () {
					// TODO: Try and figure out NWSE direction
					// Based on indices. Should be possible 
					// because we know the first vertex is the
					// apex of the triangle, and the others are
					// wound in CCW direction.

					if ( this.v1 > this.v2 > this.v3 ) {
						return NORTH;
					}

					if (this.v1 > this.v2 < this.v3 ) {
						return WEST;
					}

					if (this.v1 < this.v2 < this.v3 ) {
						return SOUTH;
					}

					return EAST;

					// TODO: Should test this by setting vertex colors based on these values;

				},
				
				split: function () {
					if (this.bn) {
						if (this.bn.bn != this) {
							this.bn.split();
						}
						this.split2();
						this.lc.rn = this.bn.rc;
						this.rc.ln = this.bn.lc;
						this.bn.lc.rn = this.rc;
						this.bn.rc.ln = this.lc;
					} else {
						this.split2();
						this.lc.rn = null;
						this.rc.ln = null;
					}
				},
				
				split2 : function () {
					// TODO: How on earth do I get the correct indexes to fill
					// the constructors for these triangles... ? 

					this.lc = new Triangle((resolution*(resolution-1)+resolution-1)/2, this.v2, this.v3);
					this.rc = new Triangle((resolution*(resolution-1)+resolution-1)/2, this.v3, this.v2);

					// TODO: ---------- Needs fixing ------------

					this.lc.ln = this.rc;
					this.rc.rn = this.lc;
					this.lc.bn = this.ln;
					
					if (this.ln) {
						if (this.ln.bn == this) {
							this.ln.bn = this.lc;
						} else {
							if ( this.ln.ln == this ) {
								this.ln.ln = this.lc;
							} else {
								this.ln.rn = this.lc;
							}
						}
					}
					
					this.rc.bn = this.rn;
					if ( this.rn ) {
						if ( this.rn.bn == this) {
							this.rn.bn = this.rc;
						} else {
							if ( this.rn.rn == this) {
								this.rn.rn = this.rc;
							} else {
								this.rn.ln = this.rc;
							}
						}
					}
					
					this.lc.lc = null;
					this.lc.rc = null;
					this.rc.lc = null;
					this.rc.rc = null;
				},

				getVariance : function (img, geom) {
					// we pass in the geometry object to this function
					// generally the Triangle does not need to reference it
					// but here it does.
					var va = geom.vertices[this.v2];
					var vb = geom.vertices[this.v3];

					// Get the center of the hypotenuse of this triangle.
					var hypc = va.copy().lerp(vb, 0.5);
					// Sample the heightmap at this location
					var sampledHeight = getNormalizedHeight(img, hypc.x, hypc.z );
					// return the variance, both values are somewhere between 0.0 - 1.0;
					return Math.abs(hypc.y - sampledHeight);
				},

				getIndexBuffers : function () {
					if (!this.lc) {
						return [new THREE.Face3(this.v1, this.v2, this.v3)];
						
					} else {
						var ret = [];
						ret = ret.concat(this.lc.getIndexBuffers());
						ret = ret.concat(this.rc.getIndexBuffers());
						return ret;
					}
					
				}
			}
			
		
			$(document).ready(function () {
				three = THREE.Bootstrap();
				var context = createBuffer(257, 257);
				var img = new Image();
				img.onload = function () {
					drawImage(this, context);
				}
				img.src="img/hm.jpg";
				
				var geom = createGeometry();
				
				// Always start at the triangle apex.

				var triA = new Triangle ( 0, resolution*(resolution-1), resolution-1 );
				var triB = new Triangle ( resolution*(resolution-1)+resolution-1, resolution-1, resolution*(resolution-1) );



				//triA.setBottomNeighbour(triB);
				//triB.setBottomNeighbour(triA);

				//triB.split();

				/*
					20  21  22  23  24

					15  16  17  18  19

					10  11  12  13  14

					5   6   7   8   9

				+z	0   1   2   3   4
				^
				|
					-> +x
				
				Is this right ?


				*/



				triA.lc = new Triangle(12, 0, 20);
				triA.rc = new Triangle(12, 4, 0);

				triB.lc = new Triangle(12, 20, 24);
				triB.rc = new Triangle(12, 24, 4);

				var indexes = [];

				var triOneIndexes = triA.getIndexBuffers();
				var triTwoIndexes = triB.getIndexBuffers();


				for ( var i = 0; i < triOneIndexes.length; i++ ) {
					geom.faces.push ( triOneIndexes[i] );
				}

				for ( var i = 0; i < triTwoIndexes.length; i++ ) {
					geom.faces.push ( triTwoIndexes[i] );
				}
				geom.computeFaceNormals();
				geom.computeVertexNormals();
				
				var object = new THREE.Mesh( geom, new THREE.MeshBasicMaterial({wireframe:true, color:'blue'}));
				//var object = new THREE.Mesh( geom, new THREE.MeshNormalMaterial());
				three.scene.add(object);
				
				var axes = new THREE.AxisHelper(100);
				three.scene.add(axes);

				three.on('update', function () {
					var t = three.Time.now;
				  three.camera.position.set(100, 200, -300);
				  three.camera.lookAt(new THREE.Vector3());
				});
				
				
			});

		</script>
	</body>
</html>
